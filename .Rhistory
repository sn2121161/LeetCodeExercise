def MinPositive(list:nums):
count = 0
nums.sort()
for i in range(len(nums)):
if nums[i] <= 0:
count += 1
return nums[count]
print(MinPositive(nums))
# input
nums = [2,3,-1,-11,-323,1,5,32,33]
# output: 32
def Max(list:nums):
temp = 0
for i in range(1, len(nums)):
if nums[i] >= nums[temp]:
temp = i
return nums[temp]
print(Max(nums))
# input
nums = [-1,0,1,2,-1,-4]
target = 0
# output
def ThreeSums(list: nums, int: target):
res = []  # 解的容器
nums.sort()  # 先对数组进行排序
for i in range(len(nums)-1):   # 指针a
left = i+1  # 指针b
right = len(nums)-1  # 指针c
if nums[i] == nums[i-1]:  #这是指针a自己的判断，判断前一个后一个是否相等
continue  # 跳过相同值得指针得计算
while left < right:
sums = nums[i] + nums[left] + nums[right]
if sums == target and nums[right] != nums[left]:
res.append( [nums[i], nums[left], nums[right]] )  # 符合的加入解集
left += 1 # 接着往后计算
# 其实去掉也行嘛
# if nums[left] == nums[left - 1]: # 指针b得前后值相同
# left += 1
# right -= 1  # else
# if nums[right] == nums[right + 1]:
# right -= 1
elif sums < target:
left += 1
else:
right -= 1
return res
print(ThreeSums(nums, target))
# input
nums = [[1,2,3], [4,5,6], [4,5,6], [1,2,3]]
# output: [[1,2,3], [4,5,6]]
def eliminate(list: nums) -> list:
di = {}
for i, v in enumerate(nums):
di[str(v)] = i
return di.keys()
print(eliminate(nums))
class Hashmap():
def __init__(self):
self.hashmap = [-1 for _ in range(10**3)]  # 构造一个全是-1的元素表
def add(self, key, value):
self.hashmap[key] = value
def get(self, key):
return self.hashmap[key]
def remove(self, key):
self.hashmap[key] = -1
h = Hashmap()
h.add(1, 2)
h.add(10, 4)
print(h.get(10))
print(h.get(1))
print(h.get(5))
h.remove(1)
print(h.get(1))
# input
nums = [[1,2,3], [2,5,8], [7,12,13]]
# output: [[1,8], [10,12,13]]
def CombineSame(nums):
res = []
left = nums[0][0]
right = nums[0][-1]
counter = 0
while counter <= len(nums)-2:
if nums[counter][-1] >= nums[counter+1][0]:
right = nums[counter+1][-1]
nums[counter] = [left, right]
counter += 1
res.append(nums[counter])
return res
print(CombineSame(nums))
# input
nums = [1,2,3,4,5]
target = 3
# output [1,2,4,5,5]
# 两层for循环
def delete0(nums, target):
for i in range(len(nums)):
if nums[i] == target:
for j in range(0, i):
nums[i+j] = nums[j+i+1]
return nums, len(nums)
# 双指针
def delete1(nums, target):
slow = 0  # 慢指针
for i in range(len(nums)):  # 快指针
if nums[i] != target:
nums[slow] = nums[i]  # 对非目标元素进行一一赋值
slow += 1   # 慢指针也需要移动
return slow
print(delete0(nums, target))
print(delete1(nums, target))
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
# 为什么function3是不对的
"""
因为左边和右边代表着两个之间必有一个是全局最大，最大的在新数组中放在最优的位置，而你通过两侧的指针不能确定全局最小在哪里，要从中心往外延申
append也不对，因为append是从最小的开始往数组里加
"""
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
right += 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
# 为什么function3是不对的
"""
因为左边和右边代表着两个之间必有一个是全局最大，最大的在新数组中放在最优的位置，而你通过两侧的指针不能确定全局最小在哪里，要从中心往外延申
append也不对，因为append是从最小的开始往数组里加
"""
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
right += 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
reticulate::repl_python()
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
# 为什么function3是不对的
"""
因为左边和右边代表着两个之间必有一个是全局最大，最大的在新数组中放在最优的位置，而你通过两侧的指针不能确定全局最小在哪里，要从中心往外延申
append也不对，因为append是从最小的开始往数组里加
"""
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 and right <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
right -= 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
# 为什么function3是不对的
# 因为左边和右边代表着两个之间必有一个是全局最大，最大的在新数组中放在最优的位置，而你通过两侧的指针不能确定全局最小在哪里，要从中心往外延申
# append也不对，因为append是从最小的开始往数组里加
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 and right <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
right -= 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 left <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
left += 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 left <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
left += 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
# input
nums = [-8, 2, 3, 5, 7]
# output [1,4,9,25,49]
def function1(nums):
a = list(map(lambda x:x**2, nums))
a.sort()
return a
def function2(nums):
res = [0 for _ in range(len(nums))]   # 生成一个有值的数组，然后从数组的最右侧开始像最左侧赋值
left = 0
right = k = len(nums)-1
while left <= right:
if pow(nums[left], 2) > pow(nums[right], 2):
res[k] = pow(nums[left], 2)
k -= 1
left += 1
else:
res[k] = pow(nums[right], 2)
k -= 1
right -= 1
return res
def function3(nums):
res = [0 for _ in range(len(nums))]
k = left = 0
right = len(nums)-1
while left <= right:
if pow(nums[left],2) > pow(nums[right], 2):
res[k] = pow(nums[right],2)
k += 1
left += 1
else:
res[k] = pow(nums[left], 2)
k += 1
right -= 1
return res
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 left <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
left += 1
return res
print(function1(nums))
print(function2(nums))
print(function4(nums))
fdfd
fd
fdfd
#input
nums = [-8, 1,3,4,6,7]
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 left <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
left += 1
return res
print(function4(nums))
#input
nums = [-8, 1,3,4,6,7]
def function4(nums):
res = []  # 空列表，从最小的开始加入
left = len(nums) // 2
right = left + 1
while left >= 0 and left <= len(nums)-1:
if nums[left] **2 > nums[right] **2:
res.append(nums[right] ** 2)
left -= 1
else:
res.append(nums[left] ** 2)
left += 1
return res
print(function4(nums))
